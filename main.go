// This command is a Git hook for executing tests. It is intended to be used as the pre-commit hook.
package main

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"os"
	"os/exec"
)

// stdout contains the standard output. We use it for allow tests to change the destination of the output.
var stdout io.Writer = os.Stdout

// stdout contains the os.Exit function. We use it for allow tests to change the what the exit do.
var exit = os.Exit

func main() {
	stderr := new(bytes.Buffer)
	results := new(bytes.Buffer)
	ok, err := runTests(stderr, results)
	if err != nil {
		panic(err)
	}

	if !ok {
		fmt.Fprintln(stdout, results.String())
		if stderr.Len() > 0 {
			fmt.Fprintln(stdout, stderr.String())
		}
		exit(1)
	}
}

// runTests calls go test on the packages. The standard error of the command is written to stderr. Test fails are written to results.
// If the go test command runs successfully and all tests pass then ok will be true.
func runTests(stderr, results *bytes.Buffer) (ok bool, err error) {
	ok = true

	cmd := exec.Command("go", "test", "-json", "-timeout=10s", "-vet=off", "."+string(os.PathSeparator)+"...")

	stdout := new(bytes.Buffer)

	cmd.Stdout = stdout
	cmd.Stderr = stderr

	err = cmd.Run()
	if exitError := new(exec.ExitError); errors.As(err, &exitError) {
		ok = false
	} else if err != nil {
		return ok, err
	}
	err = nil

	dec := json.NewDecoder(stdout)
	for {
		var te testEvent
		if err := dec.Decode(&te); err == io.EOF {
			break
		} else if err != nil {
			return ok, err
		}

		if te.Action != "fail" {
			continue
		}

		if te.Test == "" {
			continue
		}

		fmt.Fprintf(results, "%s: %s failed\n", te.Package, te.Test)

		ok = false
	}

	return
}

// testEvent is a event generated by the test command.
type testEvent struct {
	Action  string
	Package string
	Test    string
}
