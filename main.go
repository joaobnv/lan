// This command is a Git hook. It is intended to be used as the pre-commit hook.
package main

// Copyright (c) 2025, Jo√£o Breno. See the license.

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go/ast"
	"go/types"
	"io"
	"os"
	"os/exec"
	"regexp"
	"slices"
	"strings"
	"time"
	"unicode"
	"unicode/utf8"

	"golang.org/x/tools/go/packages"
)

// stdout contains the standard output. We use it for allow tests to change the destination of the output.
var stdout io.Writer = os.Stdout

// exit contains the os.Exit function. We use it for allow tests to change what the exit do.
var exit = os.Exit

// packagesPath contains the path to be used for running the tests and vet. We use it for allow tests to change that path.
var packagesPath = "." + string(os.PathSeparator) + "..."

// checkHasTestsPackagesPath contains the path to be used for verifiyng if the packages have tests. We use it for allow tests
// to change that path.
var checkHasTestsPackagesPath = "." + string(os.PathSeparator) + "..."

// packageTestTimeout is the timeout of the tests of each package. We use it for allow tests to change that duration.
var packageTestTimeout time.Duration = 30 * time.Second

// executeVet is wheter is to run vet or not. We use it for allow tests to change the execution or not of vet.
var executeVet = true

func main() {
	results := new(bytes.Buffer)
	if executeVet {
		ok, err := runVet(results)
		if err != nil {
			panic(err)
		}
		if !ok {
			fmt.Fprintln(stdout, results.String())
			exit(1)
			return // maybe the exit function was changed in tests
		}
	}

	results.Reset()
	ok, err := runTests(results)
	if err != nil {
		panic(err)
	}

	if !ok {
		fmt.Fprintln(stdout, results.String())
		exit(1)
		return
	}

	results.Reset()
	if ok, err = verifyIfHasTests(results); err != nil {
		panic(err)
	}

	if !ok {
		fmt.Fprintln(stdout, results.String())
		exit(1)
		return
	}
}

// runVet calls go vet on the packages. Vet fails are written to results.
// If the go vet command runs successfully and pass then ok will be true.
func runVet(results *bytes.Buffer) (ok bool, err error) {
	cmd := exec.Command("go", "vet", packagesPath)
	cmd.Stderr = results

	err = cmd.Run()
	if exitError := new(exec.ExitError); errors.As(err, &exitError) {
		return false, nil
	} else if err != nil {
		return ok, err
	}

	return true, nil
}

var coverageRe = regexp.MustCompile(`^coverage: (\d{1,3}(?:\.\d)?)% of statements\n$`)

// runTests calls go test on the packages. Test fails are written to results.
// If the go test command runs successfully and all tests pass and the coverage
// is 100% then ok will be true.
func runTests(results *bytes.Buffer) (ok bool, err error) {
	ok = true

	cmd := exec.Command("go", "test", "-json", "-timeout="+packageTestTimeout.String(), "-vet=off", "-cover", packagesPath)

	stdout := new(bytes.Buffer)

	cmd.Stdout = stdout

	err = cmd.Run()
	if exitError := new(exec.ExitError); errors.As(err, &exitError) {
		ok = false
	} else if err != nil {
		return ok, err
	}
	err = nil

	dec := json.NewDecoder(stdout)
	for {
		var te testEvent
		if err := dec.Decode(&te); err == io.EOF {
			break
		} else if err != nil {
			return ok, err
		}

		if te.Action == "fail" {
			if te.Test == "" {
				continue
			}

			fmt.Fprintf(results, "%s: %s failed\n", te.Package, te.Test)
			ok = false
		} else if te.Action == "output" && strings.HasPrefix(te.Output, "panic: test timed out after") {
			fmt.Fprintf(results, "%s: %s\n", te.Package, te.Output)
			ok = false
		} else if te.Action == "output" && coverageRe.MatchString(te.Output) {
			submatches := coverageRe.FindAllStringSubmatch(te.Output, -1)
			if submatches[0][1] != "100.0" {
				fmt.Fprintf(results, "%s: test coverage is not 100.0%%\n", te.Package)
				ok = false
			}
		}

	}

	return
}

// testEvent is a event generated by the test command.
type testEvent struct {
	Action  string
	Package string
	Test    string
	Output  string
}

// verifyIfHasTests verify for each package if it need and has tests.
func verifyIfHasTests(results *bytes.Buffer) (ok bool, err error) {
	cfg := &packages.Config{
		Mode:  packages.NeedName | packages.NeedSyntax | packages.NeedTypesInfo,
		Tests: true,
	}
	pkgs, err := packages.Load(cfg, checkHasTestsPackagesPath)
	if err != nil {
		return ok, err
	}

	var needTest []string
	var withTests []string

	for _, pkg := range pkgs {
		if strings.HasSuffix(pkg.PkgPath, ".test") {
			continue
		}
		if !needTests(pkg) {
			continue
		}
		needTest = append(needTest, pkg.PkgPath)
		if hasTests(pkg) {
			withTests = append(withTests, pkg.PkgPath)
		}
	}

	ok = true
	for _, pkg := range pkgs {
		if strings.HasSuffix(pkg.PkgPath, ".test") {
			continue
		}
		if slices.Contains(needTest, pkg.PkgPath) && !slices.Contains(withTests, pkg.PkgPath) {
			fmt.Fprintf(results, "%s has no tests\n", pkg.PkgPath)
			ok = false
		}
	}

	return
}

// needTests reports wheter pkg need tests.
func needTests(pkg *packages.Package) bool {
	for _, s := range pkg.Syntax {
		f := pkg.Fset.File(s.FileStart)
		if strings.HasSuffix(f.Name(), "_test.go") {
			continue
		}

		for _, d := range s.Decls {
			if _, ok := d.(*ast.FuncDecl); ok {
				return true
			}
		}
	}

	return false
}

// hasTests reports wheter pkg has tests.
func hasTests(pkg *packages.Package) bool {
	for _, s := range pkg.Syntax {
		f := pkg.Fset.File(s.FileStart)
		if !strings.HasSuffix(f.Name(), "_test.go") {
			continue
		}

		for _, d := range s.Decls {
			f, ok := d.(*ast.FuncDecl)
			if !ok {
				continue
			}
			if isTestFunction(pkg.TypesInfo, f) {
				return true
			}
		}
	}

	return false
}

// isTestFunction reports wheter f has the signature of a test function.
func isTestFunction(ti *types.Info, f *ast.FuncDecl) bool {
	if isFuzzTestFunction(ti, f) {
		return true
	}

	if !strings.HasPrefix(f.Name.Name, "Test") {
		return false
	}

	if startWithLowerCaseLetter(strings.TrimPrefix(f.Name.Name, "Test")) {
		return false
	}

	sig := ti.Defs[f.Name].Type().(*types.Signature)
	if sig.Params().Len() != 1 {
		return false
	}

	paramPointer, ok := sig.Params().At(0).Type().(*types.Pointer)
	if !ok {
		return false
	}

	paramNamed, ok := paramPointer.Elem().(*types.Named)
	if !ok {
		return false
	}

	if pkg := paramNamed.Obj().Pkg(); pkg == nil || pkg.Path() != "testing" {
		return false
	}

	if paramNamed.Obj().Name() != "T" {
		return false
	}

	return true
}

// isFuzzTestFunction reports wheter f has the signature of a fuzz test function.
func isFuzzTestFunction(ti *types.Info, f *ast.FuncDecl) bool {
	if !strings.HasPrefix(f.Name.Name, "Fuzz") {
		return false
	}
	if startWithLowerCaseLetter(strings.TrimPrefix(f.Name.Name, "Fuzz")) {
		return false
	}

	sig := ti.Defs[f.Name].Type().(*types.Signature)
	if sig.Params().Len() != 1 {
		return false
	}

	paramPointer, ok := sig.Params().At(0).Type().(*types.Pointer)
	if !ok {
		return false
	}

	paramNamed, ok := paramPointer.Elem().(*types.Named)
	if !ok {
		return false
	}

	if pkg := paramNamed.Obj().Pkg(); pkg == nil || pkg.Path() != "testing" {
		return false
	}

	if paramNamed.Obj().Name() != "F" {
		return false
	}

	return true
}

// startWithLowerCaseLetter reports if s start with a lower case letter.
func startWithLowerCaseLetter(s string) bool {
	r, _ := utf8.DecodeRuneInString(s)
	return unicode.IsLower(r)
}
